### 第一章
#### 数据的表示
**进制的转换：**
    
按权展开法，该方法通常用于低进制转高进制使用
        
            2进制转10进制
        例如：10100.01=1*2^4+0+1*2^2+0+0+0+1*2^-2 => 得到十进制数 20.25
            7进制转10进制
        例如：604.02 = 6*7^2+0+4*7^1+0+2*7^-2 得到十进制数 ...
        
短除法，该方法通常用于高进制转低进制使用

![](../image/1.jpg)

另外，二进制转八进制与十六进制数有其他方法，如下图：

![](../image/2.jpg)
**说明：**
每三位为一个十进制数

每4个为一个十进制，十进制数为超过9之后，用字母A~F顺序替代超过10的数

另外有凑数方法的计算，可以针对于高进制转低进制的转换，例：
    
    十进制的10转成2进制
    2^4 2^3 2^2 2^1 2^0
    16 8 4 2 1
    0  1 0 1 0
    选择凑数的为1，其余为0，这里只有8+2等于10，则：
    01010，可以得到二进制数为1010
    
##### 原码反码补码移码
![](../image/1600011291.jpg)

    对于这个图，唯一想解释的点，就这个移码：
    就是首位取反，缘由为用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。
    而实际上这个数是无限接近于零的。那么我们就需要取出其中的 "-0“ 值作为机器零。
##### 扩展：
    阶码：
    想想10进制，125=0.125*10^3
    那么可以说任意一个J进制数N，总可以写成
              N  =   M  * J^e
    其中M是数N的尾数，M是一个纯小数
    e就是N的阶码
    J^e是比例因子
    那么这个数N的小数点位置就随着比例因子的变化而浮动，这就是浮点表示法
    阶码是浮点表示法中的概念
    增加尾数位数可提高数据精度，增加阶码位数能增大表示的数据区域

#### 数值取值范围
![](../image/1600012589.jpg)
    
    如：一个字节用8个bit位表示，则
    原码取值范围为:
    -(2^8-1 - 1)~2^8-1 - 1 => -127~127
    反码：
    -(2^8-1 - 1)~2^8-1 - 1 => -127~127
    补码：
    -（2^8-1） ~ 2^8-1 - 1 => -128~127
    这里解释为什么补码会比原码和反码多一个bit位呢？
    我们要先区分一下原码、反码和补码的表示规则：
    
    0的表示：
    
    原码：有正零和负零之分，[+0]补=0000 0000，[-0]补=1000 0000;

    反码：同样有两种表示方法，[+0]反=0000 0000 ，[-0]反=1111 1111；

    补码：零只有一种表示方法，不分正负，[0]补=0000 0000；
    
    8为二进制表示的范围为：
          一个字节8位，如果采用原码表示正整数（含0），可以表达0-255，即 2^8=256，一共256种状态，从全0到全1的各种排列组合。如果要表示负数，则符号位需要占用一位（最高位，1代表负数，0代表正数），因此其绝对值最大范围为0-127，即2^7=128，一共正负各128种状态，如果不采用特殊处理，这时候0占用2个编码（10000000和00000000），数据表示范围为-127到-0及+0到127，这样总体上一个字节只有255种状态，因为其中0具有正0和负0之分，这不符合数学意义也浪费一个编码。
    
          除了以上的弊端，还有个原因是，早期硬件很昂贵，一位或者一个编码的浪费都是不可饶恕的，因此人们想到了另一种编码把负0利用起来，即当遇到负数时，采用补码来表示就可以解决这个问题，而遇到正数或0时还是保留原码表示。因此这个负0通过补码算法处理后自然而然地被利用起来，用来表示-128.
             补码的算法为：绝对值的原码各位取反后加1.
            例1：负1的补码：
            绝对值的8位原码为00000001
            取反：11111110
            加1 ：11111111
            此时最高位被处理为1，满足高位为1代表负数的定义。
            例2：负128的补码：
            绝对值的8位原码为10000000
            取反：01111111
            加1 ：10000000
    此时同样的最高位被置为1，同样满足高位为1代表负数的定义,同时原先表示负0的编码被利用起来表示-128。
    因此一个字节的有符号整数范围为-128到127。
    综上为：
         原码+反码：8位原码和反码能够表示数的范围是-127~127；
    
         补码：8位补码能够表示数的范围是 -128~127。
    
         （在补码中用(-128)代替了(-0)，所以补码的表示范围为：(-128~0~127)共256个
![](../image/20180919205255221.png)

### 浮点数的运算
![](../image/1.png)

    举个例子：
    首先1000 = 1.0*10^3，119 = 1.19*10^2
    那么两个浮点数相加，首先需要对阶
    e指数相等，且优先小化大，及1.19*10^2 化为 0.119*10^3 而不是10.0 * 10^2这样子，主要目的也是为了方便计算
    对阶完成之后就是，尾数计算，及相加之后为：1.119*10^2 这样的形式
    最后就是结果格式化，还是为1.119*10^2。
    要求：尾数必须大于0，且小于10

### 计算机结构
![](../image/123.png)
    
    详述如下：
        下面我们要看到的，是计算机结构当中的主机的基本构成，我们知道主机是属于计算机当中的核心部分，整个计算机的组成呢，
        就是主机加外设，那主机是不是就是我们平常所说的主机箱里面的一些部件呢？不是这么回事，我们讲到的计算机结构里面的主机，
        远比我们所接触到的，主机箱里面的部件要少，主机只包括两个部分是CPU，另外一个部分就是内存，也称为主存储器，
        这一点概念呢是需要明确的，你像硬盘，像什么声卡，显卡这些东西呢，都归为外设，只有两大部件是属于主机的，在这个结构当中，
        我们要特别注意的一点是CPU里面的运算器和控制器，因为在考试当中运算器和控制器构成，是经常考到的一个知识点，
        运算器也成为了算术逻辑单元，alu运算器，它的基本的思想或者说基本所做的工作是做预算的职能，你比如说要做一些加法减法这些东西呢，
        在运算器里面去做，但是CPU当中仅仅有运算职能部件还不够，还要去控制这个部件的相关的运作，控制整个CPU的一些交互什么之类的，
        那这个职能呢，就是由控制器来完成的，所以从整体上面来讲，我们会发现运算器里面所包含的一些内容主要是什么呢？
        算术逻辑单元这基本上呢，一眼就能够识别它跟运算相关，累加寄存器AC，听这个名词了，感觉他是做加法运算的，但事实上呢，
        它是一个通用的寄存器，就是运算的过程中，他去存一些需要运算的，相应的值的时候会要用到它，它不仅仅是加法减法运算，
        也会用到AC这样的计算器，第3个呢是数据缓冲寄存器，数据缓冲寄存器了，它是用来做什么的？就是我们在对内存储器进行读写操作的时候，
        用来暂存数据的，这样的计算器，第4个是状态条件寄存器，PSW这个非常具有特色，所以呢，经常考到，它是用来存储在运算的过程中的相关
        的标志位的，何谓标志位？为了你比如说运算有的时候涉及到境内，有些运算呢，会溢出，然后还有什么中断，等等，会涉及到一些状态的，
        信息需要保存，这就是存在PSW里面，控制器里面也会有多个相应的部件，控制器里面的部件呢，也比较好识别，你像第1类的是跟指令相关的，
        指令的寄存器l指令的译码器这些部件，因为你看到指令你就会想到，我们是在运行程序的时候，我们要调取相应的一些内容，
        调取相应的一些指令代码的内容的时候呢，就需要去控制，所以呢，指令相关的往往是和在控制器里面部件和控制项目。程序计数器是什么东西了？
        我们在进行程序运行的时候，运行了当前指令，只要运行，接下来要运行下一条指令，那运行下一条指令的时候我们需要了解下一条指令在什么位置，
        这就是由程序计数器PC，来完成的，如果说仅仅只是顺序执行，那你就在原地址的基础上去家，比如说加1，就得到了新地，
        如果说涉及到跳转的就加的幅度了，再大一些，仅此而已啊，另外一点呢就是时序部件，这是运算器和控制器，对于他常用的这一系列的寄存器，
        我们需要了解它的基本职能，哪些东西是属于运算器的部分？哪些东西又是属于控制器的部分？

### Flynn 分类法
    
    详述：
     这种分类法是针对于计算机体系结构的一种分类，如下图：
![](../image/20200914233408.jpg)

    



    
    
    
    
